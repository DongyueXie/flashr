% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/backfit.R
\name{flash_backfit}
\alias{flash_backfit}
\title{Refines a fit of the flash model to data by "backfitting".}
\usage{
flash_backfit(data, f_init, kset = NULL, var_type = c("by_column", "by_row",
  "constant", "zero", "kroneker"), tol = 0.01, ebnm_fn = "ebnm_pn",
  ebnm_param = NULL, verbose = TRUE, nullcheck = TRUE, maxiter = 1000)
}
\arguments{
\item{data}{An n by p matrix or a flash data object created using
\code{flash_set_data}.}

\item{f_init}{A fitted flash object to be refined.}

\item{kset}{The indices of factors to be optimized (\code{NULL}
indicates all factors).}

\item{var_type}{The type of variance structure to assume for
residuals. Options include:
\describe{
  \item{\code{"by_column"}}{Residuals in any given column are
    assumed to have the same variance.}
  \item{\code{"by_row"}}{Residuals in any given row have the
    same variance.}
  \item{\code{"constant"}}{All residuals are assumed to have the
    same variance.}
  \item{\code{"zero"}}{The variance of the residuals is fixed. To
    use this variance type, the standard errors must be
    specified via parameter \code{S} when using
    \code{flash_set_data} to set the flash data object.}
  \item{\code{"kroneker"}}{This variance type has not yet been
    implemented.}
}}

\item{tol}{Specifies how much the objective can change in a single
iteration to be considered not converged.}

\item{ebnm_fn}{The function used to solve the Empirical Bayes Normal
Means problem. Either a single character string (giving the name of
of the function) or a list with fields \code{l} and \code{f}
(specifying different functions to be used for loadings and factors)
are acceptable arguments. Options include:
\describe{
  \item{\code{"ebnm_ash"}}{A wrapper to the function
    \code{\link[ashr]{ash}}.}
  \item{\code{"ebnm_pn"}}{A wrapper to function
    \code{\link[ebnm]{ebnm_point_normal}} in package \pkg{ebnm}.}
  \item{\code{"ebnm_pl"}}{A wrapper to function
    \code{\link[ebnm]{ebnm_point_laplace}} in \pkg{ebnm}.}
}}

\item{ebnm_param}{A named list containing parameters to be passed to
\code{ebnm_fn} when optimizing. A list with fields \code{l} and
\code{f} (each of which is a named list) will separately supply
parameters for the loadings and factors. An unnamed list of
\code{length(kset)} named lists will separately supply parameters
for each factor/loading in \code{kset}. Finally, a list with fields
\code{l} and \code{f}, each of which contains an unnamed list of
\code{length(kset)} named lists, will separately supply parameters
for each distinct loading and each distinct factor. Set to
\code{NULL} to use defaults.}

\item{verbose}{If \code{TRUE}, various progress updates will be
printed.}

\item{nullcheck}{If \code{TRUE}, then after running hill-climbing
updates \code{flash} will check whether the achieved optimum is
better than setting the factor to zero. If the check is performed
and fails then the factor will be set to zero in the returned fit.}

\item{maxiter}{A maximum number of iterations to perform (not
including repeated fittings if \code{nullcheck} fails). To perform
just one iteration we suggest setting \code{maxiter = 1} and
\code{nullcheck = FALSE}.}
}
\value{
A fitted flash object.
}
\description{
Iterates through the factors of a flash object,
  updating each until convergence.
}
\examples{

LL = matrix(rnorm(200), ncol=2) # simulate some rank 2 data
FF = matrix(rnorm(20), nrow=2)
Y = LL \%*\% FF + matrix(rnorm(1000), nrow=100)
fg = flash_add_greedy(Y, 10)
fb = flash_backfit(Y, fg) # refines fit from greedy by backfitting
flash_get_ldf(fb)$d

# Example to illustrate different types of arguments to ebnm_param.
# 1. Fix a N(0, 1) prior on the loadings.
ebnm_param_l = list(g=ashr::normalmix(1,0,1), fixg=TRUE)
fg2 = flash_add_greedy(Y, 10, ebnm_fn="ebnm_ash",
                       ebnm_param=list(l=ebnm_param_l, f=list()))
# 2. Now refit factors, forcing loadings to use prior from greedy fit.
ebnm_param_f = lapply(fg2$gf, function(g) {list(g=g, fixg=TRUE)})
fb2 = flash_backfit(Y, fg2, kset=1:2, ebnm_fn="ebnm_ash",
                    ebnm_param=list(l=list(), f=ebnm_param_f))

}
