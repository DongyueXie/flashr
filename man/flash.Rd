% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash.R
\name{flash}
\alias{flash}
\title{Fit Empirical Bayes Matrix Factorization}
\usage{
flash(data, Kmax = 100, f_init = NULL, var_type = c("by_column", "by_row",
  "constant", "zero", "kroneker"), init_fn = "udv_si", tol = 0.01,
  ebnm_fn = "ebnm_pn", ebnm_param = NULL, verbose = FALSE,
  nullcheck = TRUE, seed = 123, greedy = TRUE, backfit = FALSE)
}
\arguments{
\item{data}{An n by p matrix or a flash data object created using
\code{flash_set_data}.}

\item{Kmax}{The maximum number of factors to be added to the flash
object. (If \code{nullcheck = TRUE}, the actual number of factors
added might be less than \code{Kmax}.)}

\item{f_init}{The flash object to which new factors are to be added.
If \code{f_init = NULL}, then a new flash fit object is created.}

\item{var_type}{The type of variance structure to assume for
residuals.}

\item{init_fn}{The function used to initialize factors. This
function should take parameters (Y,K) where Y is an n by p matrix
of data (or a flash data object) and K is a number of factors.  It
should output a list with elements (u,d,v) where u is n by K matrix
v is a p by K matrix and d is a K vector. See \code{udv_si} for an
example.  (If the input data includes missing values then this
function must be able to deal with missing values in its input
matrix.)}

\item{tol}{Specifies how much the objective can change in a single
iteration to be considered not converged.}

\item{ebnm_fn}{The function used to solve the Empirical Bayes Normal
Means problem. Either a single character string (giving the name of
of the function) or a list with fields \code{l} and \code{f}
(specifying different functions to be used for loadings and factors)
are acceptable arguments.}

\item{ebnm_param}{A named list containing parameters to be passed to
\code{ebnm_fn} when optimizing. A list with fields \code{l} and
\code{f} (each of which is a named list) will separately supply
parameters for loadings and factors. Set to NULL to use
defaults.}

\item{verbose}{If TRUE, various progress updates will be printed.}

\item{nullcheck}{If TRUE, then after running hill-climbing updates,
\code{flash} will check whether the achieved optimum is better than
setting the factor to 0. If the check is performed and fails then
the factor will be set to 0 in the returned fit.}

\item{seed}{A random number seed to use before running \code{flash}
- for reproducibility. Set to NULL if you don't want the seed set.
(The seed can affect initialization when there are missing data;
otherwise the algorithm is deterministic.)}

\item{greedy}{If TRUE, factors are added via the greedy algorithm.
If FALSE, then \code{f_init} must be supplied.}

\item{backfit}{If TRUE, factors are refined via the backfitting
algorithm.}
}
\value{
A fitted flash object. Use \code{flash_get_ldf} to access
  standardized loadings and factors; use \code{flash_get_lf} to
  access fitted LF'.
}
\description{
This is the main interface for fitting EBMF models
  based on algorithms from Wang and Stephens.  The default behaviour
  is simply to run the greedy algorithm and return the result.  To
  follow it by backfitting set \code{backfit = TRUE}.
}
\examples{

set.seed(1) # for reproducibility
ftrue = matrix(rnorm(200), ncol=2)
ltrue = matrix(rnorm(40), ncol=2)
ltrue[1:10, 1] = 0 # set up some sparsity
ltrue[11:20, 2] = 0
Y = ltrue \%*\% t(ftrue)+rnorm(2000) # set up a simulated matrix
f = flash(Y)
ldf = flash_get_ldf(f)

# Show the weights, analogous to singular values showing importance
# of each factor.
ldf$d

# Plot true l against estimated l; with this seed it turns out the
# 2nd loading/factor corresponds to the first column of ltrue.
plot(ltrue[,1], ldf$l[,2])

# Plot true f against estimated f (note estimate is normalized).
plot(ftrue[,1], ldf$f[,2])

# Plot true lf' against estimated lf'; the scale of the estimate
# matches the data.
plot(ltrue \%*\% t(ftrue), flash_get_lf(f))

# Example to use the more flexible ebnm function in ashr.
f2 = flash(Y, ebnm_fn="ebnm_ash")

# Example to show how to pass parameters to ashr (may be most
# useful for research use).
f3 = flash(Y,
           ebnm_fn="ebnm_ash",
           ebnm_param=list(mixcompdist="normal", method="fdr"))

# Example to show how to separately specify parameters for factors
# and loadings.
f4 = flash(Y,
           ebnm_fn=list(l="ebnm_pn", f="ebnm_ash"),
           ebnm_param=list(l=list(),
                           f=list(g=ashr::normalmix(1,0,1), fixg=TRUE)))

# Example to show how to use a different initialization function.
library(softImpute)
f5 = flash(Y, init_fn=function(x, K=1){softImpute(x, K, lambda=10)})

}
\seealso{
flash_add_greedy, flash_backfit
}
