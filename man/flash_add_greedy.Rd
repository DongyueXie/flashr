% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash.R
\name{flash_add_greedy}
\alias{flash_add_greedy}
\title{Fit Empirical Bayes Matrix Factorization (greedy algorithm)}
\usage{
flash_add_greedy(data, Kmax = 1, f_init = NULL, var_type = c("by_column",
  "by_row", "constant", "zero", "kroneker"), init_fn = "udv_si", tol = 0.01,
  ebnm_fn = "ebnm_pn", ebnm_param = NULL, verbose = TRUE,
  nullcheck = TRUE, seed = 123)
}
\arguments{
\item{data}{An n by p matrix or a flash data object created using
\code{flash_set_data}.}

\item{Kmax}{The maximum number of factors to be added to the flash
object.}

\item{f_init}{The flash object to which new factors are to be added.
If \code{f_init = NULL}, then a new flash fit object is created.}

\item{var_type}{The type of variance structure to assume for
residuals. Options include:
\describe{
  \item{\code{"by_column"}}{Residuals in any given column are
    assumed to have the same variance.}
  \item{\code{"by_row"}}{Residuals in any given row have the
    same variance.}
  \item{\code{"constant"}}{All residuals are assumed to have the
    same variance.}
  \item{\code{"zero"}}{The variance of the residuals is fixed. To
    use this variance type, the standard errors must be
    specified via parameter \code{S} when using
    \code{flash_set_data} to set the flash data object.}
  \item{\code{"kroneker"}}{This variance type has not yet been
    implemented.}
}}

\item{init_fn}{The function used to initialize factors. Options
include:
\describe{
  \item{\code{"udv_si"}}{Provides a simple wrapper to
    \code{\link[softImpute]{softImpute}} to provide a rank-one
    initialization. Uses option \code{type = "als"}.}
  \item{\code{"udv_si_svd"}}{Uses
    \code{\link[softImpute]{softImpute}} with option
    \code{type = "svd"}.}
  \item{\code{"udv_svd"}}{Provides a simple wrapper to \code{svd}.}
  \item{\code{"udv_random"}}{Provides a random initialization of
    factors.}
}
A user-specified function can also be used. This function should
take parameters \code{(Y, K)}, where \code{Y} is an n by p matrix of
data (or a flash data object) and \code{K} is the number of factors.
It should output a list with elements \code{(u, d, v)}, where
\code{u} is a n by K matrix, \code{v} is a p by K matrix, and
\code{d} is a K vector. (If the input data includes missing values,
then the function must be able to deal with missing values in its
input matrix.)}

\item{tol}{Specifies how much the objective can change in a single
iteration to be considered not converged.}

\item{ebnm_fn}{The function used to solve the Empirical Bayes Normal
Means problem. Either a single character string (giving the name of
of the function) or a list with fields \code{l} and \code{f}
(specifying different functions to be used for loadings and factors)
are acceptable arguments. Options include:
\describe{
  \item{\code{"ebnm_ash"}}{A wrapper to the function
    \code{\link[ashr]{ash}}.}
  \item{\code{"ebnm_pn"}}{A wrapper to function
    \code{\link[ebnm]{ebnm_point_normal}} in package \pkg{ebnm}.}
  \item{\code{"ebnm_pl"}}{A wrapper to function
    \code{\link[ebnm]{ebnm_point_laplace}} in \pkg{ebnm}.}
}}

\item{ebnm_param}{A named list containing parameters to be passed to
\code{ebnm_fn} when optimizing. A list with fields \code{l} and
\code{f} (each of which is a named list) will separately supply
parameters for loadings and factors. If parameter \code{warmstart}
is used, the current value of \code{g} (if available) will be
passed to \code{ebnm_fn}. (So, \code{ebnm_fn} should accept a
parameter named \code{g}, not one named \code{warmstart}.) Set
\code{ebnm_param} to \code{NULL} to use defaults.}

\item{verbose}{If \code{TRUE}, various progress updates will be
printed.}

\item{nullcheck}{If \code{TRUE}, then after running hill-climbing
updates \code{flash} will check whether the achieved optimum is
better than setting the factor to zero. If the check is performed
and fails then the factor will be set to zero in the returned fit.}

\item{seed}{A random number seed to use before running \code{flash}
- for reproducibility. Set to \code{NULL} if you don't want the
seed set. (The seed can affect initialization when there are
missing data; otherwise the algorithm is deterministic.)}
}
\value{
A fitted flash object.
}
\description{
This implements the greedy algorithm from Wang and
  Stephens. It can be used to adds factors to an existing fit, or
  start from scratch.  It adds factors iteratively, at each stage
  adding a new factor and then optimizing it.  It is "greedy" in that
  it does not return to re-optimize previous factors.  The function
  stops when an added factor contributes nothing, or Kmax is reached.
  Each new factor is intialized by applying the function
  \code{init_fn} to the residuals after removing previously-fitted
  factors.
}
\examples{
l = rnorm(100)
f = rnorm(10)
Y = outer(l, f) + matrix(rnorm(1000), nrow=100)
f = flash_add_greedy(Y,10)

# Gives the weights for each factor (analogue of singular values).
flash_get_ldf(f)$d

# Example to show how to use a different initialization function.
library(softImpute)
f2 = flash_add_greedy(Y, 10, init_fn=function(x, K=1) {
  softImpute(x, K, lambda=10)
})

}
