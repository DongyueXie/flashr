% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash.R
\name{flash_r1}
\alias{flash_r1}
\title{Fit the rank1 flash model to data}
\usage{
flash_r1(data, f_init = NULL, var_type = c("by_column", "constant"),
  init_fn = "udv_si", tol = 0.01, ebnm_fn = ebnm_ash,
  ebnm_param = flash_default_ebnm_param(ebnm_fn), verbose = FALSE,
  nullcheck = TRUE, seed = 123)
}
\arguments{
\item{data}{an n by p matrix or a flash data object created using \code{flash_set_data}}

\item{f_init}{if supplied, a flash object to which a single new factor is to be added}

\item{var_type}{type of variance structure to assume for residuals.}

\item{init_fn}{function to be used to initialize the factor. This function should take parameters (Y,K)
where Y is an n by p matrix of data (or a flash data object) and K is a number of factors.
It should output a list with elements (u,d,v) where u is n by K matrix
v is a p by K matrix  and d is a K vector. See \code{udv_si} for an example.
(If the input data includes missing values then this function must be able
to deal with missing values in its input matrix.)}

\item{tol}{specify how much objective can change in a single iteration to be considered not converged}

\item{ebnm_fn}{function to solve the Empirical Bayes Normal Means problem}

\item{ebnm_param}{named list containing parameters to be passed to ebnm_fn when optimizing; defaults set by flash_default_ebnm_param()}

\item{verbose}{if TRUE various output progress updates will be printed}

\item{nullcheck}{flag whether to check, after running
hill-climbing updates, whether the achieved optimum is better than setting factor to 0.
If this check is performed and fails then the factor will be set to 0 in the returned fit.}

\item{seed}{a random number seed to use before running method - for reproducibility. Set to NULL if you don't want seed set.
(The seed can affect initialization when there are missing data; otherwise the algorithm is deterministic)}
}
\value{
a fitted flash object
}
\examples{
Y = matrix(rnorm(100),nrow=5,ncol=20)
f = flash_r1(Y)
flash_get_sizes(f)
f2 = flash_r1(Y,ebnm_fn=ebnm_pn) # run with the faster ebnm function (uses point-normal prior)
# example to show how to pass parameters to ash
f3 = flash_r1(Y,ebnm_fn = ebnm_ash, ebnm_param = list(mixcompdist = "normal",method="fdr"))
}
